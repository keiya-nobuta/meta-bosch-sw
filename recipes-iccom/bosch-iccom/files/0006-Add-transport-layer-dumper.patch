From 064296b273c398278173007da270dd28e642586d Mon Sep 17 00:00:00 2001
From: Keiya Nobuta <nobuta.keiya@fujitsu.com>
Date: Sun, 5 Sep 2021 16:41:32 +0900
Subject: [PATCH 6/7] Add transport layer dumper

Signed-off-by: Keiya Nobuta <nobuta.keiya@fujitsu.com>
---
 src/Kconfig                                   |  25 +-
 src/Makefile                                  |   3 +-
 src/iccom-example.c                           | 144 --------
 src/iccom-transport-helper.c                  | 327 ++++++++++++++++++
 ...com-example.h => iccom-transport-helper.h} |   2 +-
 src/iccom_socket_if.c                         |   4 +-
 6 files changed, 349 insertions(+), 156 deletions(-)
 delete mode 100644 src/iccom-example.c
 create mode 100644 src/iccom-transport-helper.c
 rename src/{iccom-example.h => iccom-transport-helper.h} (92%)

diff --git a/src/Kconfig b/src/Kconfig
index 905c17e..6c0b85b 100644
--- a/src/Kconfig
+++ b/src/Kconfig
@@ -101,14 +101,25 @@ config BOSCH_ICCOM_WORKQUEUE_MODE
 	            in theory the option which provides the lowest
 	            latency values expectation
 
-config BOSCH_ICCOM_EXAMPLE
-	tristate "The ICCom + SymSPI example protocol module"
-	depends on BOSCH_ICCOM_SOCKETS && BOSCH_ICCOM && BOSCH_SYMSPI
-	default y
+choice
+	prompt "Transport Layer"
+	default BOSCH_ICCOM_TRANSPORT_SYMSPI
+	help
+	  ICCOM transport layer selection
+
+config BOSCH_ICCOM_TRANSPORT_SYMSPI
+	bool "SYMSPI"
 	help
-	  Adds the ICCom + SymSPI protocol configuration into
-	  the ICCom protocol options list, enabling ICCom to use
-	  it for communication.
+	  This feature selects symspi module
+
+config BOSCH_ICCOM_TRANSPORT_DUMPER
+	bool "DUMPER"
+	help
+	  This feature selects dumper module
+	  for debug
+
+endchoice
+
 
 config BOSCH_ICCOM_TRANSPORT_MIRROR_V1
 	tristate "The transport level mirrored ICCom protocol driver"
diff --git a/src/Makefile b/src/Makefile
index a02164a..27d5719 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -26,8 +26,7 @@ ifeq ($(CONFIG_BOSCH_ICCOM_TEST_MODULE), y)
     obj-m += iccom_test.o
 endif
 
-obj-$(CONFIG_BOSCH_ICCOM_SOCKETS) += iccom_socket_if.o
+obj-$(CONFIG_BOSCH_ICCOM_SOCKETS) += iccom_socket_if.o iccom-transport-helper.o
 
 # Custom protocol aggregator drivers
-obj-$(CONFIG_BOSCH_ICCOM_EXAMPLE) += iccom-example.o
 obj-$(CONFIG_BOSCH_ICCOM_TRANSPORT_MIRROR_V1) += iccom-transport-mirror-v1.o
diff --git a/src/iccom-example.c b/src/iccom-example.c
deleted file mode 100644
index 71dce32..0000000
--- a/src/iccom-example.c
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * This file defines the Inter Chip/CPU communication protocol (ICCom)
- * driver instance with example SymSPI-based configuration.
- *
- * Copyright (c) 2020 Robert Bosch GmbH
- * Artem Gulyaev <Artem.Gulyaev@de.bosch.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-// SPDX-License-Identifier: GPL-2.0
-
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/signal.h>
-#include <net/sock.h>
-#include <net/net_namespace.h>
-#include <linux/proc_fs.h>
-#include <stddef.h>
-
-#include "../symspi/symspi.h"
-#include "./iccom.h"
-
-// DEV STACK
-// @@@@@@@@@@@@@
-//
-// BACKLOG:
-//
-
-/* --------------------- BUILD CONFIGURATION ----------------------------*/
-
-#define ICCOM_EXAMPLE_LOG_PREFIX "ICCom SymSPI example: "
-
-#define ICCOM_EXAMPLE_SYMSPI_CONFIG_BITS_PER_WORD 8
-#define ICCOM_EXAMPLE_SYMSPI_CONFIG_MODE (SPI_CPOL | SPI_CPHA)
-
-/* --------------------- UTILITIES SECTION ----------------------------- */
-
-#define iccom_example_err(fmt, ...)                               \
-        pr_err(ICCOM_EXAMPLE_LOG_PREFIX"%s: "fmt"\n", __func__    \
-               , ##__VA_ARGS__)
-#define iccom_example_warning(fmt, ...)                           \
-        pr_warning(ICCOM_EXAMPLE_LOG_PREFIX"%s: "fmt"\n", __func__\
-               , ##__VA_ARGS__)
-#define iccom_example_info(fmt, ...)                              \
-        pr_info(ICCOM_EXAMPLE_LOG_PREFIX"%s: "fmt"\n", __func__   \
-                , ##__VA_ARGS__)
-
-#define fitsin(TYPE, FIELD, SIZE)                                 \
-        (offsetof(TYPE, FIELD) + sizeof(((TYPE*)(NULL))->FIELD) <= (SIZE))
-
-/* -------------------------- STRUCTS -----------------------------------*/
-
-// Defines the sample SPI transfer configuration according to the contract
-// with the other side (it is used at SymSPI layer, and sets the SPI
-// transport configuration details which are specific for given
-// communication).
-//
-// CONTEXT: can not sleep
-static void iccom_example_protocol_native_transfer_configuration_hook(
-                const struct full_duplex_xfer *const xfer
-                , void *const native_transfer
-                , const size_t native_transfer_struct_size)
-{
-        struct spi_transfer *dst = (struct spi_transfer *)native_transfer;
-
-        if (!fitsin(struct spi_transfer, bits_per_word
-                    , native_transfer_struct_size)) {
-                return;
-        }
-
-        const int SPI_FULL_WORD_SIZE_BITS = 32;
-
-        if (xfer->size_bytes * 8 >= SPI_FULL_WORD_SIZE_BITS) {
-                dst->bits_per_word = SPI_FULL_WORD_SIZE_BITS;
-        } else {
-                dst->bits_per_word = xfer->size_bytes * 8;
-        }
-}
-
-// Prepares transport protocol layer according to the
-// example communication protocol.
-//
-// RETURNS:
-struct full_duplex_device iccom_example_protocol_init_transport_layer(void)
-{
-        struct full_duplex_device ret_dev;
-        // TODO:
-        // TODO:  REALLY, TODO
-        // TODO:
-        // TODO: use DTS table to get the correct device and
-        //      don't use global one
-        struct symspi_dev *symspi = symspi_get_global_device();
-        if (IS_ERR_OR_NULL(symspi)) {
-                iccom_example_err("no SymSPI device found");
-
-                ret_dev.dev = ERR_PTR(-ENODEV);
-                ret_dev.iface = NULL;
-                return ret_dev;
-        }
-
-        symspi->spi->bits_per_word = ICCOM_EXAMPLE_SYMSPI_CONFIG_BITS_PER_WORD;
-        symspi->spi->mode |= ICCOM_EXAMPLE_SYMSPI_CONFIG_MODE;
-        symspi->spi->master->setup(symspi->spi);
-        symspi->native_transfer_configuration_hook
-                = &iccom_example_protocol_native_transfer_configuration_hook;
-
-        ret_dev.dev = (void*)symspi;
-        ret_dev.iface = symspi_iface();
-        return ret_dev;
-}
-// TODO: remove export as dependency is removed from ICCom layer
-EXPORT_SYMBOL(iccom_example_protocol_init_transport_layer);
-
-/* --------------------- MODULE HOUSEKEEPING SECTION ------------------- */
-
-static int __init iccom_example_protocol_module_init(void)
-{
-        iccom_example_info("module loaded");
-        return 0;
-}
-
-static void __exit iccom_example_protocol_module_exit(void)
-{
-        iccom_example_info("module unloaded");
-}
-
-module_init(iccom_example_protocol_module_init);
-module_exit(iccom_example_protocol_module_exit);
-
-MODULE_DESCRIPTION("The ICCom + SymSPI example communication driver"
-                   " module.");
-MODULE_AUTHOR("Artem Gulyaev <Artem.Gulyaev@bosch.com>");
-MODULE_LICENSE("GPL v2");
diff --git a/src/iccom-transport-helper.c b/src/iccom-transport-helper.c
new file mode 100644
index 0000000..637d313
--- /dev/null
+++ b/src/iccom-transport-helper.c
@@ -0,0 +1,327 @@
+/*
+ * This file defines the Inter Chip/CPU communication protocol (ICCom)
+ * transport layer helper.
+ *
+ * Copyright (c) 2020 Robert Bosch GmbH
+ * Artem Gulyaev <Artem.Gulyaev@de.bosch.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/signal.h>
+#include <linux/slab.h>
+#if defined(CONFIG_BOSCH_ICCOM_TRANSPORT_DUMPER)
+#include <linux/workqueue.h>
+#endif
+#include <net/sock.h>
+#include <net/net_namespace.h>
+#include <stddef.h>
+
+#include "./iccom.h"
+
+#if defined(CONFIG_BOSCH_ICCOM_TRANSPORT_SYMSPI)
+#include "../symspi/symspi.h"
+#endif
+
+// DEV STACK
+// @@@@@@@@@@@@@
+//
+// BACKLOG:
+//
+
+/* --------------------- BUILD CONFIGURATION ----------------------------*/
+
+#define ICCOM_HELPER_LOG_PREFIX "ICCom helper: "
+
+#define ICCOM_HELPER_SYMSPI_CONFIG_BITS_PER_WORD 8
+#define ICCOM_HELPER_SYMSPI_CONFIG_MODE (SPI_CPOL | SPI_CPHA)
+
+/* --------------------- UTILITIES SECTION ----------------------------- */
+
+#define iccom_helper_err(fmt, ...)                               \
+        pr_err(ICCOM_HELPER_LOG_PREFIX"%s: "fmt"\n", __func__    \
+               , ##__VA_ARGS__)
+#define iccom_helper_warning(fmt, ...)                           \
+        pr_warning(ICCOM_HELPER_LOG_PREFIX"%s: "fmt"\n", __func__\
+               , ##__VA_ARGS__)
+#define iccom_helper_info(fmt, ...)                              \
+        pr_info(ICCOM_HELPER_LOG_PREFIX"%s: "fmt"\n", __func__   \
+                , ##__VA_ARGS__)
+
+#define fitsin(TYPE, FIELD, SIZE)                                 \
+        (offsetof(TYPE, FIELD) + sizeof(((TYPE*)(NULL))->FIELD) <= (SIZE))
+
+/* -------------------------- STRUCTS -----------------------------------*/
+
+#if defined(CONFIG_BOSCH_ICCOM_TRANSPORT_SYMSPI)
+#include "../symspi/symspi.h"
+// Defines the sample SPI transfer configuration according to the contract
+// with the other side (it is used at SymSPI layer, and sets the SPI
+// transport configuration details which are specific for given
+// communication).
+//
+// CONTEXT: can not sleep
+static void iccom_helper_protocol_native_transfer_configuration_hook(
+                const struct full_duplex_xfer *const xfer
+                , void *const native_transfer
+                , const size_t native_transfer_struct_size)
+{
+        struct spi_transfer *dst = (struct spi_transfer *)native_transfer;
+
+        if (!fitsin(struct spi_transfer, bits_per_word
+                    , native_transfer_struct_size)) {
+                return;
+        }
+
+        const int SPI_FULL_WORD_SIZE_BITS = 32;
+
+        if (xfer->size_bytes * 8 >= SPI_FULL_WORD_SIZE_BITS) {
+                dst->bits_per_word = SPI_FULL_WORD_SIZE_BITS;
+        } else {
+                dst->bits_per_word = xfer->size_bytes * 8;
+        }
+}
+
+// Prepares transport protocol layer according to the
+// example communication protocol.
+//
+// RETURNS:
+struct full_duplex_device iccom_protocol_init_transport_layer(void)
+{
+        struct full_duplex_device ret_dev;
+        // TODO:
+        // TODO:  REALLY, TODO
+        // TODO:
+        // TODO: use DTS table to get the correct device and
+        //      don't use global one
+        struct symspi_dev *symspi = symspi_get_global_device();
+        if (IS_ERR_OR_NULL(symspi)) {
+                iccom_helper_err("no SymSPI device found");
+
+                ret_dev.dev = ERR_PTR(-ENODEV);
+                ret_dev.iface = NULL;
+                return ret_dev;
+        }
+
+        symspi->spi->bits_per_word = ICCOM_HELPER_SYMSPI_CONFIG_BITS_PER_WORD;
+        symspi->spi->mode |= ICCOM_HELPER_SYMSPI_CONFIG_MODE;
+        symspi->spi->master->setup(symspi->spi);
+        symspi->native_transfer_configuration_hook
+                = &iccom_helper_protocol_native_transfer_configuration_hook;
+
+        ret_dev.dev = (void*)symspi;
+        ret_dev.iface = symspi_iface();
+        return ret_dev;
+}
+EXPORT_SYMBOL(iccom_protocol_init_transport_layer);
+
+#elif defined(CONFIG_BOSCH_ICCOM_TRANSPORT_DUMPER)
+
+struct dumper_device {
+	struct full_duplex_xfer current_xfer;
+	struct work_struct work;
+};
+
+static struct dumper_device dumper_dev;
+
+static void dumper_dump_xfer(struct full_duplex_xfer *xfer)
+{
+	if (!xfer || !xfer->size_bytes)
+		return;
+
+	printk("=== iccom_dumper: ICCOM DUMP START ===\n");
+	if (xfer->data_tx)
+		print_hex_dump(KERN_INFO, "xfer->tx: ", 0, 16, 1,
+			       xfer->data_tx, xfer->size_bytes, true);
+	printk("=== iccom_dumper: ICCOM DUMP END   ===\n");
+}
+
+static int dumper_copy_xfer(struct full_duplex_xfer *target, struct full_duplex_xfer *source)
+{
+	if (!source->size_bytes)
+		return 0;
+
+	if (target->size_bytes != source->size_bytes) {
+
+		target->size_bytes = source->size_bytes;
+		if (!(target->data_tx = krealloc(target->data_tx, target->size_bytes,
+						 GFP_KERNEL)))
+			goto out_of_memory;
+		if (!(target->data_rx_buf = krealloc(target->data_tx, target->size_bytes,
+						     GFP_KERNEL)))
+			goto out_of_memory;
+	}
+
+	target->id = source->id;
+	target->xfers_counter = source->xfers_counter;
+	target->consumer_data = source->consumer_data;
+	target->done_callback = source->done_callback;
+	target->fail_callback = source->fail_callback;
+
+	memcpy(target->data_tx, source->data_tx, target->size_bytes);
+
+	return 0;
+
+out_of_memory:
+	kfree(target->data_tx);
+	kfree(target->data_rx_buf);
+	target->data_tx = NULL;
+	target->data_rx_buf = NULL;
+	target->size_bytes = 0;
+
+	return -ENOMEM;
+}
+
+static void dumper_xfer_work(struct work_struct *work)
+{
+	struct full_duplex_xfer *xfer = &dumper_dev.current_xfer;
+	struct full_duplex_xfer *next_xfer = NULL;
+	struct dumper_device *dev = &dumper_dev;
+	bool start_immediately = false;
+
+	if (!xfer->size_bytes)
+		return;
+
+	dumper_dump_xfer(xfer);
+
+	if (xfer->data_rx_buf)
+		memcpy(xfer->data_rx_buf, xfer->data_tx, xfer->size_bytes);
+
+	if (xfer->done_callback) {
+		next_xfer = xfer->done_callback(xfer, 0, &start_immediately,
+						xfer->consumer_data);
+	}
+
+	if (IS_ERR(next_xfer)) {
+		printk(KERN_ERR "DUMPER ERROR in XFER state by consumer request");
+		return;
+	}
+
+	if (next_xfer) {
+		if (dumper_copy_xfer(&dev->current_xfer, next_xfer))
+			return;
+
+		if (start_immediately)
+			schedule_work(&dev->work);
+	}
+}
+
+static int dumper_data_xchange(void __kernel *device,
+			       struct __kernel full_duplex_xfer *xfer,
+			       bool force_size_change)
+{
+	struct dumper_device *dev = device;
+	int ret;
+
+	if (xfer) {
+		ret = dumper_copy_xfer(&dev->current_xfer, xfer);
+		if (ret)
+			return ret;
+
+	}
+	schedule_work(&dev->work);
+
+	return (xfer) ? xfer->id : 0;
+}
+
+static int dumper_data_update(void __kernel *device,
+			      struct full_duplex_xfer *xfer,
+			      bool force_size_change)
+{
+	struct dumper_device *dev = device;
+	int ret = 0;
+
+	if (xfer)
+		ret = dumper_copy_xfer(&dev->current_xfer, xfer);
+
+	return ret;
+}
+
+static bool dumper_is_running(void __kernel *device)
+{
+	return true;
+}
+
+static int dumper_init(void __kernel *device, struct full_duplex_xfer *default_xfer)
+{
+	struct dumper_device *dev = device;
+
+	dumper_data_update(dev, default_xfer, false);
+	return dumper_data_xchange(dev, NULL, false);
+}
+
+static int dumper_close(void __kernel *device)
+{
+	struct dumper_device *dev = device;
+
+	cancel_work_sync(&dev->work);
+	dev->current_xfer.size_bytes = 0;
+	return 0;
+}
+
+static int dumper_reset(void __kernel *device, struct full_duplex_xfer *default_xfer)
+{
+	struct dumper_device *dev = device;
+
+	dumper_close(dev);
+	dumper_init(dev, default_xfer);
+	return 0;
+}
+
+static struct full_duplex_sym_iface dumper_iface = {
+	.data_xchange = dumper_data_xchange,
+	.default_data_update = dumper_data_update,
+	.is_running = dumper_is_running,
+	.init = dumper_init,
+	.reset = dumper_reset,
+	.close = dumper_close,
+};
+
+struct full_duplex_device iccom_protocol_init_transport_layer(void)
+{
+        struct full_duplex_device ret_dev = {
+		.dev = &dumper_dev,
+		.iface = &dumper_iface,
+	};
+
+	INIT_WORK(&dumper_dev.work, dumper_xfer_work);
+	return ret_dev;
+}
+EXPORT_SYMBOL(iccom_protocol_init_transport_layer);
+#endif /* BOSCH_ICCOM_TRANSPORT_DUMPER */
+
+static int __init iccom_transport_helper_init(void)
+{
+	return 0;
+}
+
+module_init(iccom_transport_helper_init);
+
+static void __exit iccom_transport_helper_exit(void)
+{
+	struct dumper_device *dev = &dumper_dev;
+	struct full_duplex_xfer *xfer = &dev->current_xfer;
+
+	cancel_work_sync(&dev->work);
+	kfree(xfer->data_tx);
+	kfree(xfer->data_rx_buf);
+}
+module_exit(iccom_transport_helper_exit);
+
+MODULE_DESCRIPTION("InterChipCommunication protocol helper module.");
+MODULE_AUTHOR("Artem Gulyaev <Artem.Gulyaev@bosch.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/src/iccom-example.h b/src/iccom-transport-helper.h
similarity index 92%
rename from src/iccom-example.h
rename to src/iccom-transport-helper.h
index bfa0504..bd1ac76 100644
--- a/src/iccom-example.h
+++ b/src/iccom-transport-helper.h
@@ -25,4 +25,4 @@
 
 #include "../full_duplex_interface/full_duplex_interface.h"
 
-struct full_duplex_device iccom_example_protocol_init_transport_layer(void);
+struct full_duplex_device iccom_protocol_init_transport_layer(void);
diff --git a/src/iccom_socket_if.c b/src/iccom_socket_if.c
index 2fa0282..1329b61 100644
--- a/src/iccom_socket_if.c
+++ b/src/iccom_socket_if.c
@@ -38,7 +38,7 @@
 //      it is only temporary change while migration on graceful
 //      architecture is ongoing.
 // TODO: remove the dependency
-#include "./iccom-example.h"
+#include "./iccom-transport-helper.h"
 
 // DEV STACK
 // @@@@@@@@@@@@@
@@ -893,7 +893,7 @@ static int __iccom_socket_protocol_device_init(
         //      transport protocol drivers, nor byte transfer protocol
         //      drivers
         const struct full_duplex_device transport
-                    = iccom_example_protocol_init_transport_layer();
+                    = iccom_protocol_init_transport_layer();
 
         // TODO: ultimate binding shall happen in the ultimate protocol
         //      driver and happen between specific instances of layers
-- 
2.25.1

